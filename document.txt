Проблеммы:
#. Не всегда нейросети удается обучиться
   {
       Возможно нарушена логика программы
   }
#. Иногда графики слишком резко убывают
#. Я не уверен что с системой классов графики корректны   
#. всегда создается 1 скрытый слой
#. Какая то проблемма с весами

#. При подачи нового образца по хорошему надо бы получать новые Y(можно коррекцию Y в метод завернуть)
#Неправельные Error в скрытом слое(запускать нейросеть прежде чем обучать ее на новый образец).

#.W[0] не равно 1.





Идеи:
#.На каждом графике должны отображаться все образцы.
#. Дать возможность пользователю выбирать
    {
        Функцию активации
        (
            При выборе другой функции, нейросеть перестает обучиться
        ) 
        Однослойную нейросеть
    }
#. После каждой итерации запускать нейросеть тем самым получай новые выходы(именно так оно и работает).




Задачи: 
#. Сделать режим Распознования 
#. Маштаб графиков равен среднему арефметическому.
#. Изменить кнопку скрытия структуры
#. Любое количество слоев
#.Y на поверхности получатся из функции стоимости из W1 и W2
#. убрать Функцию активации
#. зафиксировать W0 +





с 1: 0.999967598336989
с 0: 0.9999813443654153


Правило формирования ошибки
1) Берутся выходы 
2) из ожидаемых значений вычетаются выходы
3) Умножаются на производную функции и на коэфицент a(ошибки для выходного слоя)
4)суммируются по правилу 
#На первый нейрон в слое приходит ошибка с первыми весами нейронов следущего слоя.
5) умножаются на производную функции
6) подаются на нейроны по логиге из 4 номера(Все остальные слоя)
* нулевой вес корректируется


SystemClass-->
            GAllError[0].push(JSON.parse(JSON.stringify(AllError)));
            GlWAll[0].push(JSON.parse(JSON.stringify(WAll)));
            GlYAll[0].push(JSON.parse(JSON.stringify(YAll)));
            if(YAll[Object.keys(YAll).length-1][0] >0.5 && d[0] == 1){Sravn.push(true)}
            else if(YAll[Object.keys(YAll).length-1][0] <0.5 && d[0] == 0){Sravn.push(true);}
            else{Sravn.push(false)};
            RD.push(d);
            var itogX= '';
            for(var i = 0; i <X.length; i++)
            {
                itogX += X[i] + ' ';
            }
            RX.push(itogX);
            dAll.push(d[0]);
            
            if(XC != LMX.length-1)
        {
            XC +=1; 
            
            X = LMX[XC].split(',');

            for(var i = 0; i < X.length; i++)
            {
                X[i] = +X[i]//вход
            }
            tic = 0
            return false;
        }else
        {
            CSK +=1;
            /*GAllError[0].push(JSON.parse(JSON.stringify(AllError)));
            GlWAll[0].push(JSON.parse(JSON.stringify(WAll)));
            GlYAll[0].push(JSON.parse(JSON.stringify(YAll)));
            */
            XC = 0;
            if(CSK >= MD.length)
            {
                return true
            }
            
            d = MD[CSK].split(',');
            LMX = MX[CSK].split(';');
            if(LMX.length>1)
            LMX.pop();

            X = LMX[XC].split(',');

            for(var i = 0; i < d.length; i++)
            {
                d[i] = +d[i]//ожидания
            }

            for(var i = 0; i < X.length; i++)
            {
                X[i] = +X[i]//вход
            }
            tic = 0
            return false;

        }

